'''
1. 아이디어
-> while문으로 특정 종료 조건까지 반복
-> 4방향을 for문으로 탐색
-> 더이상 탐색 불가능할 경우, 뒤로 후진 / 불가능할 경우 종료

2. 시간복잡도
-> O(NM) => 50*50 = 2,500 (2억보다 적으니 해결 가능)

3. 자료구조
-> 전체 지도 int[][]
-> 로봇청소기 위치 y,x 빙향 d 전체 청소한 개수 cnt
==> 프로그래밍에서의 좌표는 x,y가 아님을 주의 !!


'''

import sys
input = sys.stdin.readline

N,M = map(int,input().split())
y,x,d = map(int,input().split())
grp = [list(map(int,input().split()))for i in range(N)]
cnt = 0
# 이때, 방향을 나타낼 수 있는 벡터가 필요하며, 0~3으로 제시해줌.
# 하지만 다르게 보면, dy, dx로 나타낼 수 있음.
dy = [-1,0,1,0] # 각각 짝 지어보면, 0,1,2,3 방향을 나타냄
dx = [0,1,0,-1]
# 이 방향을 문제에서는 왼쪽 방향으로 돈다 = 반시계방향

while 1:
  if grp[y][x] == 0: # 1. 현재 자리가 0이라면 청소하기
    grp[y][x] = 2
    cnt += 1
  # 2. 현재 방향의 왼쪽 방향부터 4방향을 탐색 시작한다.
  sw = False # 4방향 체크를 위한 스위치. 처음엔 0이되, 청소를 1개라도 한다면 1로 변경
  for i in range(1,5): 
    ny = y + dy[d-i] 
    # 다음 탐색할 방향인 ny는 현재 방향 y에서 왼쪽방향을 보기
    # dy의 역순으로 탐색해야 반시계 방향이므로 i를 빼주기
    nx = x + dx[d-i]

    # **** 중요한 것 !! 
    # 2차원 그래프/좌표로 탐색할 땐, 새로 구한 좌표가 우리의 조건 내에 들어오는지 반드시 확인해야 됨.
    if 0<=ny<N and 0<=nx<M:
      # 3. 탐색할 방향 상태가 0이라면, 해당 방향으로 회전 후 전진 > 1번 실행
      if grp[ny][nx] == 0 :
        #d = d-i 단지 이렇게 작성한다면, 인덱스 에러 발생.
        # 나눈 몫만큼의 값으로 변경. 이는 계속 양수로 유지하게 해줌
        d = (d-i+4) % 4
        y= ny
        x= nx
        sw = True
        break

  if sw==False: # 4방향 모두 청소하지 않은 경우, 즉 sw가 그대로 false인 경우
    # 바라보는 방향을 유지한 채로, 한칸 후진하기
    # 후진해야 되는데 뒤가 벽일 경우, 종료
    ny = y - dy[d]
    nx = x - dx[d]
    if 0<=ny<N and 0<=nx<M:
      if grp[ny][nx] == 1:
        break
      else:
        y = ny
        x = nx
    else:
      #	더이상 갈 곳이 없으면 반복문 나오기
      break

print(cnt)


