'''
1.아이디어
    n미터 벽 > 1칸씩 n개의 구역 > 1~n번 벽
    롤러의 길이 m
    벽에서 벗어날 수 없음(상하좌우 경계에 맞춰서)
    구역의 일부분만 칠할 수 없음
    최소한의 횟수로 필요 구역 다 색칠하기 > 최소 횟수 return
    ---> 1번째 아이디어: 배열을 매번 참조해야 하므로, 시간복잡도 매우 터짐.
    1) n개의 벽 배열을 0으로 초기화한다
    2) 칠해야 하는 구역들의 값을 +1씩 증가한다
    3) m개의 서브 집합을 만들고, 해당 집한 안에 1의 개수를 센다 -> 1이 가장 많이 들어있는 서브 집합을 선택해서 색칠(0으로 만든다) + cnt+=1
    4) 벽에 1이 남아있다면, 다시 반복 / 1이 안 남아있다면, cnt 출력
    ---> 2번째 아이디어: 필요한 구역에서 부터 m만큼 칠하고, 다음 구역으로 이동
    1) 다음 구역이, 이전에 칠한 마지막 구역보다 작으면 다시 계산
2. 변수
    벽의 크기 int n, 롤러의 길이 int m
    다시 칠해야 하는 구역들의 번호 int[]
    반환할 결과 int cnt
3. 시간복잡도
    
'''
def solution(n, m, section):
    # 변수 초기화
    cnt = 0 # 롤링 횟수
    idx = 0 # section에서 한 개씩 꺼내서 칠하기
    
    while idx < len(section):
        
        start = section[idx]
        end = start + m
        cnt += 1
        
        while idx < len(section) and section[idx] < end: # 필요한 구역이 아직 남아있으면서, 이전에 칠했던 구역 넘어갈 때까지 idx 넘기기
            idx += 1
        
    return cnt